# The Yaml Project

Cloud infrastructure runs on YAML. Kubernetes, CI/CD pipelines,
infrastructure-as-code — all depend on YAML parsers that behave
identically across every language and platform. We need standardized,
verified parsers for the future of the cloud.

This project allows us to complete the hard and tireless work of the
YAML spec creators and maintainers — by executing their spec directly
and ensuring every parser stays faithful to what they defined.

YAML 1.2 parsers generated by a Futamura projector from a single grammar specification.

## What this is

One grammar. Eighteen languages. Every parser generated in seconds
directly from the spec.

| Language | File | Lines | Tests |
|---|---|---|---|
| C++ | `peg_yaml.cpp` | 2,197 | 308/308 |
| Rust | `peg_yaml.rs` | 1,793 | 308/308 |
| Go | `peg_yaml.go` | 1,995 | 308/308 |
| Python | `peg_yaml.py` | 1,575 | 308/308 |
| C# | `PegYaml.cs` | 1,894 | 308/308 |
| F# | `PegYaml.fs` | 1,611 | 308/308 |
| Java | `YamlReader.java` | 1,757 | 308/308 |
| Kotlin | `PegYaml.kt` | 1,805 | 308/308 |
| Haskell | `PegYaml.hs` | 1,926 | 308/308 |
| Swift | `PegYaml.swift` | 1,911 | 308/308 |
| Objective-C | `PegYaml.m` | 2,174 | 308/308 |
| Zig | `peg_yaml.zig` | 2,156 | 308/308 |
| OCaml | `peg_yaml.ml` | 1,504 | 308/308 |
| Erlang | `peg_yaml.erl` | 1,677 | 308/308 |
| Lua | `peg_yaml.lua` | 1,850 | 308/308 |
| Bash | `peg_yaml.sh` | 2,397 | 308/308 |
| PowerShell | `peg_yaml.ps1` | 1,845 | 308/308 |
| x86-64 asm | `peg_yaml.x86` | 8,570 | 94/402 |

**45,557 lines** of generated parser code from one grammar. All parsers
pass **308/308** valid tests from the
[YAML Test Suite](https://github.com/yaml/yaml-test-suite).
The x86-64 assembly target is experimental — it assembles, links, and
passes 94 tests as proof of concept.

## Why now

Futamura projection was described in 1971. PEG grammars have been
around since 2004. The YAML spec has been formal since 2009. These
ideas existed in separate domains — programming language theory,
parsing research, and data serialization. This project connects them.

AI didn't invent anything here. It was the tool that made the assembly practical — iterating on 211 rules across eighteen languages is tedious work. But the architecture has been possible since the '70s.

Because the projector executes the grammar directly, errors in the spec itself become visible. This process uncovered a bug in [Rule 78 of the YAML 1.2 specification](https://github.com/yaml/yaml-spec/issues/356) — and its implications across dependent rules. Hand-written parsers can silently work around spec errors without ever noticing them. A projector cannot — it does exactly what the spec says, which means spec bugs have nowhere to hide.

When a spec error is found or the grammar is updated, all parsers are regenerated at once. One fix, every language, in seconds. If features are added to YAML, the grammar is updated and every parser is regenerated — no per-language maintenance required. If an entirely new format is needed — such as a safe subset of YAML — a new grammar can be written and all parsers generated from scratch.

## How it works

The YAML 1.2 specification defines 211 grammar productions. These are encoded in a grammar file where code and data exist in the same domain — the grammar is both a description of YAML and an executable program. A projector reads the grammar and a target specification (300–500 lines per language), then emits a complete, working parser.

Adding a new language means writing a target spec. The projector does the rest — in seconds.

```
grammar        ─┐
                 ├──▶  projector  ──▶  parser in any language
target-spec    ─┘
```

## Futamura projection

In 1971, Yoshihiko Futamura described how partially evaluating an interpreter with respect to a program produces a compiled version of that program. This project is a practical implementation of that idea: the grammar is the program, the PEG combinator framework is the interpreter, and the projector specializes one against the other to produce standalone parsers.

Each parser is a single, self-contained file with no external dependencies. The parser can be extracted from the included main and added directly to any project — 100% standalone, no runtime, no framework, no library to install.

## The grammar

The YAML 1.2 spec is written as a formal grammar in Haskell-like notation — but in five places, the spec drops out of formal productions and resorts to English prose. Every YAML implementer must interpret these passages independently, which is why parsers diverge.

This project formalizes all five as executable grammar extensions:

1. **Auto-detect indentation** (`detect_indent`) — The spec says to "detect the indentation level" without defining how. The grammar implements this as a lookahead computation that scans forward to find the next non-empty line and derives the indent delta.

2. **Flow context switching** (`IN-FLOW`) — The spec describes context transitions between FLOW-OUT, FLOW-IN, BLOCK-KEY, and FLOW-KEY in a prose table. The grammar encodes this as an inline function: FLOW-OUT/FLOW-IN map to FLOW-IN, BLOCK-KEY/FLOW-KEY map to FLOW-KEY.

3. **Sequence spaces** (`SEQ-SPACES`) — A spec footnote says the indentation is "n-1 for BLOCK-OUT context, n otherwise." The grammar captures this as a one-line function threaded through the relevant rules.

4. **Block header binding** (`let m`, `let t`) — Rules 162, 170, and 174 require parsing a chomping indicator and indentation indicator mid-rule, then threading the results (`m` for indent, `t` for chomping style) into subsequent productions. The spec describes this flow in prose. The grammar uses a `let` form that binds intermediate parse results and passes them forward.

5. **Bounded indentation** (`s_indent_lt`, `s_indent_le`) — The spec says "less than n spaces" and "less than or equal to n spaces" but the formal grammar notation can't express bounded repetition as a constraint. The grammar implements these as runtime-checked space counts.

The grammar file encodes all 211 spec productions plus these five extensions. The projector reads this grammar and emits complete parsers — the extensions project into each target language just like the formal rules do.

## Projected vs Generated

A code *generator* uses templates to emit code. The templates are hand-written, the mapping from spec to output is arbitrary, and different generators can produce different results from the same input. The output depends on the generator author's interpretation.

A *projector* is different. It partially evaluates an interpreter with respect to a program. The YAML grammar is the program. The PEG combinator framework is the interpreter. The projector specializes one against the other — the result is the only possible output of that specialization. There is no interpretation, no template, no hand-written mapping. The grammar executes itself.

This means every projected parser is structurally identical to the spec. If the spec says rule 63 is an alternation of rules 64 and 65, the output is an alternation of rules 64 and 65. No human decision sits between the spec and the code.

**How new languages are added**

Each target language needs a *target spec* — 300–500 lines that tells the projector how the language expresses functions, closures, sequences, alternatives, and pattern matching. This is the only hand-written part, and AI can create it.

Given an existing target spec as a reference, AI can produce a new spec for any language in a single conversation. The projector then generates the complete parser — 1500–8500 lines — in seconds. The output is deterministic: the same grammar and target spec always produce the same parser.

The target spec is small enough to audit by hand. The projected output is verifiable against the YAML Test Suite. The grammar is readable and corresponds 1:1 with the YAML 1.2 specification.

## Architecture

Each parser has the same structure:

- **Input** — position-tracked source with codepoint access
- **Combinators** — `seq`, `alt`, `star`, `plus`, `opt`, `neg`, `minus`, `ahead`, `behind`, `rep`
- **YAML extensions** — `build`, `scalar`, `collect`, `detect_indent`
- **211 grammar rules** — directly corresponding to the YAML 1.2 spec
- **AST** — tree of tagged nodes with scalar leaves
- **Schema coercion** — YAML core schema (null, bool, int, float, string)
- **Anchor/alias resolution** — with merge key (`<<`) support
- **Public API** — `load(string) → native value`

## Usage

Every parser works the same way:

```bash
# C++
echo "a: 1" | ./yaml-reader

# Go
echo "a: 1" | ./yaml-reader

# Bash
echo "a: 1" | bash peg_yaml.sh

# Python
echo "a: 1" | python3 peg_yaml.py

# PowerShell
echo "a: 1" | pwsh peg_yaml.ps1
```

Output:
```
OK: 4 chars
STREAM
  DOC
    MAPPING
      PAIR
        SCALAR: "a"
        SCALAR: "1"
```

## Test suite

Tested against the [YAML Test Suite](https://github.com/yaml/yaml-test-suite) (data-2022-01-17 release): 308 valid tests, 95 error tests, 402 total.

All parsers pass **308/308 valid tests** (100%). The x86-64 assembly
target passes 94/402 (experimental).

The 94 error tests check for semantic constraints — things like duplicate keys, invalid tag usage, and context-dependent restrictions that go beyond the grammar. These are not structural parsing errors that the grammar can catch; they require a separate semantic validation layer. The projected parsers handle the structural parsing defined by the spec. Semantic validation is handled by the concern layer, which is a separate projection phase.

The build and test scripts themselves are also projected — generated from `build-spec.scm`, a declarative specification that defines each target's compiler, interpreter, dependencies, and test configuration. One spec, 18 build scripts.

## Building

```bash
# Build and test a single language
./build-go.sh
./build-rust.sh
./build-python.sh
./build-cpp.sh
./build-java.sh
./build-kotlin.sh
./build-csharp.sh
./build-fsharp.sh
./build-haskell.sh
./build-swift.sh
./build-objc.sh
./build-zig.sh
./build-ocaml.sh
./build-erlang.sh
./build-lua.sh
./build-bash.sh
./build-powershell.sh
./build-x86.sh
```

Each script checks prerequisites, builds (if compiled), runs the full
test suite, and reports the score.

## Why not just use an existing YAML library?

Most YAML libraries don't fully implement the 1.2 spec. Many fail on edge cases around block scalars, chomping indicators, multi-line plain scalars, flow collections, and directive handling. These parsers are generated directly from the formal grammar — they handle the full spec by construction.

## The future: AI should build atoms, not code

The traditional approach to AI-assisted programming is to generate code. The problem is that generated code is dead on arrival — the moment the spec changes, the requirements shift, or you want to add error messages, you regenerate and lose everything, or you hand-edit and lose the ability to regenerate.

The future of AI is not generating code. It is building **atoms** — the small, composable, auditable specifications that projectors use to generate code. A target spec is an atom. The grammar is an atom. The concern layer that adds error messages is an atom.

This project illustrates the concept:

- **Spec changes?** Update the grammar atom, regenerate all 18 parsers in seconds.
- **Better error messages?** Update the concern atom, regenerate.
- **New language?** AI writes a 300–500-line target spec atom, the projector does the rest.
- **New format entirely?** Write a new grammar atom, reuse every target spec.

AI should not be writing 2,000-line parsers. AI should be writing 300–500-line atoms that a projector expands into 2,000-line parsers. The atoms are small enough to audit, version, and understand. The generated output is verified by test suites, not by reading code.

When AI builds atoms instead of code, nothing is thrown away. Every regeneration is faithful to every atom. The code is always in sync with the spec. This is how we should be building software.

This idea is not new. John McCarthy saw it in 1958 when he created Lisp — code and data in the same domain. Futamura formalized it in 1971. This project is a practical proof that they were right.

## Author

Claude, directed by John Grillo

John Grillo is a full-time C++ programmer whose hobby over the last
20 years has been metaprogramming — always wanting something better,
always searching for the next level of code generation. He finally
reached the end of the road with a Futamura projector, built with AI.

More languages soon.

## License

MIT

