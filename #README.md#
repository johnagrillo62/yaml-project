# yaml-grammar

YAML 1.2 parsers generated by a Futamura projector from a single grammar specification.

## What this is

One grammar. Twelve languages. Every parser passes **308/308** valid tests from the [YAML Test Suite](https://github.com/yaml/yaml-test-suite). Generated in seconds directly from the spec.

| Language    | File                    | Lines |
|-------------|-------------------------|-------|
| C++         | `yaml-reader-peg.cpp`   | ~2000 |
| Rust        | `yaml_reader_peg.rs`    | ~1900 |
| Go          | `yaml_reader.go`        | ~2000 |
| Python      | `yaml_reader.py`        | ~1500 |
| C#          | `yaml-reader-peg.cs`    | ~1800 |
| Java        | `YamlReader.java`       | ~2100 |
| Haskell     | `YamlReader.hs`         | ~1800 |
| Objective-C | `YAMLReader.m`          | ~2100 |
| Bash        | `yaml_reader.sh`        | ~2500 |
| Kotlin      | *coming soon*           |       |
| Swift       | *coming soon*           |       |
| Zig         | *coming soon*           |       |

## Why now

Futamura projection was described in 1971. PEG grammars have been around since 2004. The YAML spec has been formal since 2009. These ideas existed in separate domains — programming language theory, parsing research, and data serialization. This project connects them.

AI didn't invent anything here. It was the tool that made the assembly practical — iterating on 211 rules across thirteen languages is tedious work. But the architecture has been possible since the '70s.

Because the projector executes the grammar directly, errors in the spec itself become visible. This process uncovered a bug in [Rule 78 of the YAML 1.2 specification](https://github.com/yaml/yaml-spec/issues/356) — and its implications across dependent rules. Hand-written parsers can silently work around spec errors without ever noticing them. A projector cannot — it does exactly what the spec says, which means spec bugs have nowhere to hide.

When a spec error is found or the grammar is updated, all parsers are regenerated at once. One fix, every language, in seconds. If features are added to YAML, the grammar is updated and every parser is regenerated — no per-language maintenance required. If an entirely new format is needed — such as a safe subset of YAML — a new grammar can be written and all parsers generated from scratch.

## How it works

The YAML 1.2 specification defines 211 grammar productions. These are encoded in a grammar file where code and data exist in the same domain — the grammar is both a description of YAML and an executable program. A projector reads the grammar and a target specification (~200 lines per language), then emits a complete, working parser.

Adding a new language means writing a target spec. The projector does the rest — in seconds.

```
grammar        ─┐
                 ├──▶  projector  ──▶  parser in any language
target-spec    ─┘
```

## Futamura projection

In 1971, Yoshihiko Futamura described how partially evaluating an interpreter with respect to a program produces a compiled version of that program. This project is a practical implementation of that idea: the grammar is the program, the PEG combinator framework is the interpreter, and the projector specializes one against the other to produce standalone parsers.

Each parser is a single, self-contained file with no external dependencies. The parser can be extracted from the included main and added directly to any project — 100% standalone, no runtime, no framework, no library to install.

## The grammar

The YAML 1.2 spec is written as a formal grammar in Haskell-like notation — but in five places, the spec drops out of formal productions and resorts to English prose. Every YAML implementer must interpret these passages independently, which is why parsers diverge.

This project formalizes all five as executable grammar extensions:

1. **Auto-detect indentation** (`detect_indent`) — The spec says to "detect the indentation level" without defining how. The grammar implements this as a lookahead computation that scans forward to find the next non-empty line and derives the indent delta.

2. **Flow context switching** (`IN-FLOW`) — The spec describes context transitions between FLOW-OUT, FLOW-IN, BLOCK-KEY, and FLOW-KEY in a prose table. The grammar encodes this as an inline function: FLOW-OUT/FLOW-IN map to FLOW-IN, BLOCK-KEY/FLOW-KEY map to FLOW-KEY.

3. **Sequence spaces** (`SEQ-SPACES`) — A spec footnote says the indentation is "n-1 for BLOCK-OUT context, n otherwise." The grammar captures this as a one-line function threaded through the relevant rules.

4. **Block header binding** (`let m`, `let t`) — Rules 162, 170, and 174 require parsing a chomping indicator and indentation indicator mid-rule, then threading the results (`m` for indent, `t` for chomping style) into subsequent productions. The spec describes this flow in prose. The grammar uses a `let` form that binds intermediate parse results and passes them forward.

5. **Bounded indentation** (`s_indent_lt`, `s_indent_le`) — The spec says "less than n spaces" and "less than or equal to n spaces" but the formal grammar notation can't express bounded repetition as a constraint. The grammar implements these as runtime-checked space counts.

The grammar file encodes all 211 spec productions plus these five extensions. The projector reads this grammar and emits complete parsers — the extensions project into each target language just like the formal rules do.

## Projected vs Generated

A code *generator* uses templates to emit code. The templates are hand-written, the mapping from spec to output is arbitrary, and different generators can produce different results from the same input. The output depends on the generator author's interpretation.

A *projector* is different. It partially evaluates an interpreter with respect to a program. The YAML grammar is the program. The PEG combinator framework is the interpreter. The projector specializes one against the other — the result is the only possible output of that specialization. There is no interpretation, no template, no hand-written mapping. The grammar executes itself.

This means every projected parser is structurally identical to the spec. If the spec says rule 63 is an alternation of rules 64 and 65, the output is an alternation of rules 64 and 65. No human decision sits between the spec and the code.

**How new languages are added**

Each target language needs a *target spec* — approximately 300-500
lines that tells the projector how the language expresses functions,
closures, sequences, alternatives, and pattern matching. This is the
only hand-written part, and AI can create the quickly.

Given an existing target spec as a reference, AI can produce a new
spec for any language in a single conversation. The projector then
generates the complete parser — 1800-2200 lines — in seconds. The
output is deterministic: the same grammar and target spec always
produce the same parser.

The target spec is small enough to audit by hand. The projected output
is verifiable against the YAML Test Suite. The grammar is readable and
corresponds 1:1 with the YAML 1.2 specification.

## Architecture

Each parser has the same structure:

- **Input** — position-tracked source with codepoint access
- **Combinators** — `seq`, `alt`, `star`, `plus`, `opt`, `neg`, `minus`, `ahead`, `behind`, `rep`
- **YAML extensions** — `build`, `scalar`, `collect`, `detect_indent`
- **211 grammar rules** — directly corresponding to the YAML 1.2 spec
- **AST** — tree of tagged nodes with scalar leaves
- **Schema coercion** — YAML core schema (null, bool, int, float, string)
- **Anchor/alias resolution** — with merge key (`<<`) support
- **Public API** — `load(string) → native value`

## Usage

Every parser works the same way:

```bash
# C++
echo "a: 1" | ./yaml-reader

# Go
echo "a: 1" | ./yaml-reader

# Bash
echo "a: 1" | bash yaml_reader.sh

# Python
echo "a: 1" | python3 yaml_reader.py
```

Output:
```
OK: 4 chars
STREAM
  DOC
    MAPPING
      PAIR
        SCALAR: "a"
        SCALAR: "1"
```

## Test suite

Tested against the [YAML Test Suite](https://github.com/yaml/yaml-test-suite) (data-2022-01-17 release): 308 valid tests, 95 error tests, 403 total.

All parsers pass **308/308 valid tests** (100%).

The 95 error tests check for semantic constraints — things like duplicate keys, invalid tag usage, and context-dependent restrictions that go beyond the grammar. These are not structural parsing errors that the grammar can catch; they require a separate semantic validation layer. The projected parsers handle the structural parsing defined by the spec. Semantic validation is handled by the concern layer, which is a separate projection phase.

## Building

```bash
# Build all parsers
make all

# Build a single language
make go
make python
make bash
```

Or just use the pre-built parsers in `gen/`.

## Why not just use an existing YAML library?

Most YAML libraries don't fully implement the 1.2 spec. Many fail on edge cases around block scalars, chomping indicators, multi-line plain scalars, flow collections, and directive handling. These parsers are generated directly from the formal grammar — they handle the full spec by construction.

## License

MIT
